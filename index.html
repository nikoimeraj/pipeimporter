<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Pipedrive Data Importer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f8f9fa;
        }
        h1 {
            color: #333;
        }
        label {
            margin-right: 5px;
        }
        input[type="text"] {
            padding: 5px;
            margin-right: 10px;
        }
        button {
            padding: 8px 12px;
            margin-top: 5px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 10px;
        }
        table th, table td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        table th {
            background-color: #f2f2f2;
        }
        .mapping-select {
            width: 100%;
        }
        .suggestion-block {
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 5px;
        }
        .org-selection-help {
            margin-top: 6px;
            font-size: 0.9em;
            color: #555;
            line-height: 1.4;
        }
        /* Tab styles */
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .toggle-btn {
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 6px 12px;
        }
        .toggle-btn:hover {
            background-color: #0056b3;
        }
        .toggle-btn:focus {
            outline: 2px solid #0056b3;
            outline-offset: 2px;
        }
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f2f2f2;
            margin-top: 10px;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 10px 16px;
            transition: 0.3s;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #ccc;
        }
        .tabcontent {
            display: none;
            padding: 10px;
            border: 1px solid #ccc;
            border-top: none;
        }
    </style>
</head>
<body>

<h1>Pipedrive Data Importer</h1>

<section id="connection-section">
    <h2>Connection</h2>
    <label for="subdomain">Company Subdomain:</label>
    <input type="text" id="subdomain" placeholder="e.g. company" />
    <label for="apitoken">API Token:</label>
    <input type="text" id="apitoken" placeholder="your API token" />
    <button id="fetchFieldsBtn">Fetch Fields</button>
    <p id="connectionStatus" style="color:red"></p>
</section>

<section id="fields-section" style="display:none;">
    <div class="section-header">
        <h2>Organization &amp; Person Fields</h2>
        <button type="button" id="toggleFieldsBtn" class="toggle-btn" aria-expanded="true" aria-controls="fieldsContent">Hide Fields</button>
    </div>
    <div id="fieldsContent">
        <!-- Tab buttons -->
        <div class="tab">
            <button class="tablinks" id="orgTabBtn" onclick="openTab(event, 'OrgFieldsTab')">Organization Fields</button>
            <button class="tablinks" id="personTabBtn" onclick="openTab(event, 'PersonFieldsTab')">Person Fields</button>
        </div>
        <!-- Tab content -->
        <div id="OrgFieldsTab" class="tabcontent">
            <table id="orgFieldsTable"></table>
        </div>
        <div id="PersonFieldsTab" class="tabcontent">
            <table id="personFieldsTable"></table>
        </div>
    </div>
</section>

<section id="upload-section" style="margin-top:20px;">
    <h2>Upload CSV</h2>
    <input type="file" id="csvFileInput" accept=".csv" />
    <div id="csvMappingSection"></div>
</section>

<section id="search-section" style="margin-top:20px; display:none;">
    <h2>Organization &amp; Person Suggestions</h2>
    <button id="searchRecordsBtn">Search Existing Records</button>
    <div id="suggestionSection">
        <div id="orgSuggestionSection"></div>
        <div id="personSuggestionSection"></div>
    </div>
</section>

<section id="push-section" style="margin-top:20px; display:none;">
    <button id="pushDataBtn">Push Data to Pipedrive</button>
    <p id="pushStatus"></p>
</section>

<script>
(function () {
  if (window.__pipeImporterInitialized) return;
  window.__pipeImporterInitialized = true;

  // Single shared state
  const state = (window.__pipeImporterState ??= {
    orgFields: [],
    personFields: [],
    csvData: [],
    columnMappings: {},
    organizationSuggestions: {},
    personSuggestions: {},
    isFieldsCollapsed: false
  });

  // Utils
  const normalizeNameKey = v => (v ? v.trim().toLowerCase() : '');

  function populateMappingOptions(select) {
    select.innerHTML = '';
    const add = (value, label) => {
      const o = document.createElement('option');
      o.value = value; o.textContent = label; select.appendChild(o);
    };
    add('', '-- Ignore --');
    add('person_name', 'Person Name');
    add('organization_name', 'Organization Name');
    add('note', 'Note');

    if (state.orgFields.length) {
      const g = document.createElement('optgroup'); g.label = 'Organization Fields';
      state.orgFields.forEach(f => {
        const o = document.createElement('option');
        o.value = `orgField:${f.key}`; o.textContent = f.name; g.appendChild(o);
      });
      select.appendChild(g);
    }
    if (state.personFields.length) {
      const g = document.createElement('optgroup'); g.label = 'Person Fields';
      state.personFields.forEach(f => {
        const o = document.createElement('option');
        o.value = `personField:${f.key}`; o.textContent = f.name; g.appendChild(o);
      });
      select.appendChild(g);
    }
    add('add_new_field', 'Add new field');
  }

  function refreshMappingSelectOptions() {
    document.querySelectorAll('.mapping-select').forEach(select => {
      const col = select.dataset.column;
      const current = state.columnMappings[col] || '';
      populateMappingOptions(select);
      select.value = Array.from(select.options).some(o => o.value === current) ? current : '';
      state.columnMappings[col] = select.value;
      select.dataset.previousValue = select.value;
    });
  }

  function toggleFieldsSection() {
    const content = document.getElementById('fieldsContent');
    const btn = document.getElementById('toggleFieldsBtn');
    state.isFieldsCollapsed = !state.isFieldsCollapsed;
    const collapsed = state.isFieldsCollapsed;
    content.style.display = collapsed ? 'none' : 'block';
    btn.textContent = collapsed ? 'Show Fields' : 'Hide Fields';
    btn.setAttribute('aria-expanded', String(!collapsed));
  }

  async function fetchFields() {
    const subdomain = document.getElementById('subdomain').value.trim();
    const token = document.getElementById('apitoken').value.trim();
    const statusEl = document.getElementById('connectionStatus');
    if (!subdomain || !token) {
      statusEl.textContent = 'Please enter both subdomain and token.';
      return false;
    }
    statusEl.textContent = '';

    const orgUrl = `https://${subdomain}.pipedrive.com/api/v1/organizationFields?api_token=${token}`;
    const personUrl = `https://${subdomain}.pipedrive.com/api/v1/personFields?api_token=${token}`;
    try {
      const [orgRes, personRes] = await Promise.all([
        fetch(orgUrl).then(r => r.json()),
        fetch(personUrl).then(r => r.json()),
      ]);
      if (orgRes.success && personRes.success) {
        state.orgFields = orgRes.data;
        state.personFields = personRes.data;
        displayFields();
        refreshMappingSelectOptions();
        return true;
      } else {
        statusEl.textContent = 'Error fetching fields. Please check your credentials and subdomain.';
        return false;
      }
    } catch (e) {
      console.error(e);
      statusEl.textContent = 'Network error fetching fields.';
      return false;
    }
  }

  function displayFields() {
    const section = document.getElementById('fields-section');
    const content = document.getElementById('fieldsContent');
    const btn = document.getElementById('toggleFieldsBtn');
    section.style.display = 'block';
    const collapsed = state.isFieldsCollapsed;
    content.style.display = collapsed ? 'none' : 'block';
    btn.textContent = collapsed ? 'Show Fields' : 'Hide Fields';
    btn.setAttribute('aria-expanded', String(!collapsed));

    const orgTable = document.getElementById('orgFieldsTable');
    const personTable = document.getElementById('personFieldsTable');
    orgTable.innerHTML = personTable.innerHTML = '';

    const mkHeader = () => {
      const tr = document.createElement('tr');
      tr.innerHTML = '<th>Name</th><th>Key</th><th>Type</th>';
      return tr;
    };
    orgTable.appendChild(mkHeader());
    personTable.appendChild(mkHeader());

    state.orgFields.forEach(f => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${f.name}</td><td>${f.key}</td><td>${f.field_type}</td>`;
      orgTable.appendChild(tr);
    });
    state.personFields.forEach(f => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${f.name}</td><td>${f.key}</td><td>${f.field_type}</td>`;
      personTable.appendChild(tr);
    });

    // default tab
    document.getElementById('OrgFieldsTab').style.display = 'block';
    document.getElementById('orgTabBtn').classList.add('active');
  }

  function parseCSV(file) {
    const reader = new FileReader();
    reader.onload = e => {
      const lines = (e.target.result || '').split(/\r?\n/).filter(l => l.trim());
      if (!lines.length) return alert('CSV file is empty.');
      const header = lines[0].split(',');
      state.csvData = lines.slice(1).map(line => {
        const parts = line.split(',');
        const row = {};
        header.forEach((col, i) => row[col.trim()] = parts[i] ? parts[i].trim() : '');
        return row;
      });
      displayMappingOptions(header);
    };
    reader.readAsText(file);
  }

  function displayMappingOptions(columns) {
    const div = document.getElementById('csvMappingSection');
    div.innerHTML = '';
    state.columnMappings = {};
    const table = document.createElement('table');
    const hdr = document.createElement('tr');
    hdr.innerHTML = '<th>CSV Column</th><th>Map To</th>';
    table.appendChild(hdr);

    columns.forEach(col => {
      const tr = document.createElement('tr');
      const c1 = document.createElement('td'); c1.textContent = col;
      const c2 = document.createElement('td');
      const sel = document.createElement('select');
      sel.className = 'mapping-select';
      sel.dataset.column = col;
      populateMappingOptions(sel);
      sel.dataset.previousValue = sel.value;
      sel.addEventListener('change', async function () {
        if (this.value === 'add_new_field') await handleAddNewField(this, col);
        state.columnMappings[col] = this.value;
        this.dataset.previousValue = this.value;
      });
      c2.appendChild(sel);
      tr.append(c1, c2);
      table.appendChild(tr);
    });

    div.appendChild(table);
    document.getElementById('search-section').style.display = 'block';
    document.getElementById('push-section').style.display = 'block';
  }

  async function searchExistingRecords() {
    const subdomain = document.getElementById('subdomain').value.trim();
    const token = document.getElementById('apitoken').value.trim();
    if (!subdomain || !token) return alert('Please enter both subdomain and token before searching.');

    const orgNameCol = Object.keys(state.columnMappings).find(c => state.columnMappings[c] === 'organization_name');
    const personNameCol = Object.keys(state.columnMappings).find(c => state.columnMappings[c] === 'person_name');
    if (!orgNameCol && !personNameCol) return alert('Please map a column to "Organization Name" or "Person Name" before searching.');

    state.organizationSuggestions = {};
    state.personSuggestions = {};
    const orgContainer = document.getElementById('orgSuggestionSection');
    const personContainer = document.getElementById('personSuggestionSection');
    orgContainer.innerHTML = personContainer.innerHTML = '';

    if (orgNameCol) {
      const unique = new Map();
      state.csvData.forEach(r => {
        const raw = r[orgNameCol]; const k = normalizeNameKey(raw);
        if (k && !unique.has(k)) unique.set(k, raw.trim());
      });
      if (unique.size) {
        const h = document.createElement('h3'); h.textContent = 'Organization Suggestions'; orgContainer.appendChild(h);
      }
      for (const [key, name] of unique.entries()) {
        try {
          const terms = [name.trim(), name.trim().split(/\s+/)[0]].filter(Boolean);
          const suggestions = [];
          const seen = new Set();
          for (const t of terms) {
            const url = `https://${subdomain}.pipedrive.com/api/v1/organizations/search?term=${encodeURIComponent(t)}&fields=name&limit=5&api_token=${token}`;
            const data = await fetch(url).then(r => r.json());
            (data.data?.items ?? []).forEach(e => {
              const it = e.item; if (!it || seen.has(it.id)) return; seen.add(it.id); suggestions.push(it);
            });
          }
          state.organizationSuggestions[key] = suggestions;

          const block = document.createElement('div'); block.className = 'suggestion-block';
          const title = document.createElement('strong'); title.textContent = `Suggestions for "${name}":`; block.appendChild(title);
          const sel = document.createElement('select');
          sel.dataset.name = name; sel.dataset.key = key; sel.dataset.recordType = 'organization';
          const optNew = document.createElement('option'); optNew.value = 'new'; optNew.textContent = '-- Create New --'; sel.appendChild(optNew);
          suggestions.forEach(it => {
            const o = document.createElement('option'); o.value = it.id; o.textContent = `${it.name} (ID: ${it.id})`; sel.appendChild(o);
          });
          block.appendChild(document.createElement('br')); block.appendChild(sel);
          const help = document.createElement('p'); help.className = 'org-selection-help';
          help.textContent = 'Selecting "-- Create New --" creates a new organization for rows with this name. Choosing an existing one links rows to that record and updates mapped org fields.';
          block.appendChild(help);
          orgContainer.appendChild(block);
        } catch (e) { console.error('org suggestions', e); }
      }
    }

    if (personNameCol) {
      const unique = new Map();
      state.csvData.forEach(r => {
        const raw = r[personNameCol]; const k = normalizeNameKey(raw);
        if (k && !unique.has(k)) unique.set(k, raw.trim());
      });
      if (unique.size) {
        const h = document.createElement('h3'); h.textContent = 'Person Suggestions'; personContainer.appendChild(h);
      }
      for (const [key, name] of unique.entries()) {
        try {
          const terms = Array.from(new Set([name.trim(), ...name.trim().split(/\s+/).filter(w => w.length > 1)]));
          const suggestions = []; const seen = new Set();
          for (const t of terms) {
            const url = `https://${subdomain}.pipedrive.com/api/v1/persons/search?term=${encodeURIComponent(t)}&fields=name&limit=5&api_token=${token}`;
            const data = await fetch(url).then(r => r.json());
            (data.data?.items ?? []).forEach(e => {
              const it = e.item; if (!it || seen.has(it.id)) return; seen.add(it.id); suggestions.push(it);
            });
          }
          state.personSuggestions[key] = suggestions;

          const block = document.createElement('div'); block.className = 'suggestion-block';
          const title = document.createElement('strong'); title.textContent = `Suggestions for "${name}":`; block.appendChild(title);
          const sel = document.createElement('select');
          sel.dataset.name = name; sel.dataset.key = key; sel.dataset.recordType = 'person';
          const optNew = document.createElement('option'); optNew.value = 'new'; optNew.textContent = '-- Create New --'; sel.appendChild(optNew);
          suggestions.forEach(it => {
            const o = document.createElement('option'); o.value = it.id;
            const orgName = it.organization ? (it.organization.name || it.organization) : null;
            o.textContent = orgName ? `${it.name} (ID: ${it.id}, Org: ${orgName})` : `${it.name} (ID: ${it.id})`;
            sel.appendChild(o);
          });
          block.appendChild(document.createElement('br')); block.appendChild(sel);
          const help = document.createElement('p'); help.className = 'org-selection-help';
          help.textContent = 'Selecting "-- Create New --" creates a new person (linked to mapped org). Choosing an existing person links rows to that record and updates mapped person fields.';
          block.appendChild(help);
          personContainer.appendChild(block);
        } catch (e) { console.error('person suggestions', e); }
      }
    }
  }

  async function pushDataToPipedrive() {
    const subdomain = document.getElementById('subdomain').value.trim();
    const token = document.getElementById('apitoken').value.trim();
    const pushStatus = document.getElementById('pushStatus');
    pushStatus.textContent = 'Processingâ€¦';

    const orgSelects = document.querySelectorAll('#orgSuggestionSection select[data-record-type="organization"]');
    const personSelects = document.querySelectorAll('#personSuggestionSection select[data-record-type="person"]');
    const selectedOrg = {}; orgSelects.forEach(s => selectedOrg[s.dataset.key] = s.value);
    const selectedPerson = {}; personSelects.forEach(s => selectedPerson[s.dataset.key] = s.value);

    for (const row of state.csvData) {
      // ORG
      let orgId = null; const orgPayload = {}; let orgNameValue = '';
      for (const col in state.columnMappings) {
        const map = state.columnMappings[col], val = row[col];
        if (!val) continue;
        if (map === 'organization_name') {
          orgNameValue = val.trim();
          const choice = selectedOrg[normalizeNameKey(val)];
          if (choice && choice !== 'new') orgId = choice; else if (orgNameValue) orgPayload.name = orgNameValue;
        } else if (map?.startsWith('orgField:')) {
          orgPayload[map.split(':')[1]] = val;
        }
      }
      if (!orgId && orgPayload.name) {
        const res = await fetch(`https://${subdomain}.pipedrive.com/api/v1/organizations?api_token=${token}`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(orgPayload)
        }).then(r => r.json());
        if (res.success) orgId = res.data.id;
      } else if (orgId && Object.keys(orgPayload).length) {
        await fetch(`https://${subdomain}.pipedrive.com/api/v1/organizations/${orgId}?api_token=${token}`, {
          method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(orgPayload)
        });
      }

      // PERSON
      const personFields = {}; let personName = '';
      for (const col in state.columnMappings) {
        const map = state.columnMappings[col], val = row[col];
        if (!val) continue;
        if (map === 'person_name') personName = val.trim();
        else if (map?.startsWith('personField:')) personFields[map.split(':')[1]] = val;
      }
      let personId = null;
      if (personName) {
        const choice = selectedPerson[normalizeNameKey(personName)];
        if (choice && choice !== 'new') {
          personId = choice;
          const payload = { ...personFields }; if (orgId) payload.org_id = orgId;
          if (Object.keys(payload).length) {
            await fetch(`https://${subdomain}.pipedrive.com/api/v1/persons/${personId}?api_token=${token}`, {
              method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
          }
        } else {
          const payload = { name: personName, ...personFields }; if (orgId) payload.org_id = orgId;
          const res = await fetch(`https://${subdomain}.pipedrive.com/api/v1/persons?api_token=${token}`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
          }).then(r => r.json());
          if (res.success) personId = res.data.id;
        }
      }

      // NOTE
      const noteCol = Object.keys(state.columnMappings).find(c => state.columnMappings[c] === 'note');
      if (noteCol && row[noteCol]) {
        const payload = { content: row[noteCol] };
        if (personId) payload.person_id = personId;
        else if (orgId) payload.org_id = orgId;
        await fetch(`https://${subdomain}.pipedrive.com/api/v1/notes?api_token=${token}`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
        });
      }
    }

    pushStatus.textContent = 'Data push completed.';
  }

  async function createNewField(entity, name, fieldType) {
    const subdomain = document.getElementById('subdomain').value.trim();
    const token = document.getElementById('apitoken').value.trim();
    if (!subdomain || !token) { alert('Please enter subdomain and API token before adding new fields.'); throw new Error('Missing credentials'); }
    const endpoint = entity === 'organization' ? 'organizationFields' : 'personFields';
    const url = `https://${subdomain}.pipedrive.com/api/v1/${endpoint}?api_token=${token}`;
    const res = await fetch(url, {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, field_type: fieldType, add_visible_flag: false })
    }).then(r => r.json());
    if (!res.success) throw new Error(res?.error || 'Failed to create field.');
    return res.data;
  }

  async function handleAddNewField(select, columnName) {
    const prev = select.dataset.previousValue || '';
    const entityInput = prompt('Add field to which record type? Enter "organization" or "person".');
    if (!entityInput) return (select.value = prev);
    const entity = entityInput.trim().toLowerCase();
    if (!['organization', 'person'].includes(entity)) { alert('Please enter "organization" or "person".'); return (select.value = prev); }
    const name = prompt('Enter a name for the new field:'); if (!name?.trim()) { alert('Field name is required.'); return (select.value = prev); }
    const type = prompt('Enter the field type (e.g., text, varchar, int, double, date, address, phone).'); if (!type?.trim()) { alert('Field type is required.'); return (select.value = prev); }
    try {
      const newField = await createNewField(entity, name.trim(), type.trim());
      const ok = await fetchFields(); if (!ok) return (select.value = prev);
      const mapping = `${entity === 'organization' ? 'orgField' : 'personField'}:${newField.key}`;
      state.columnMappings[columnName] = mapping;
      refreshMappingSelectOptions();
      select.value = mapping;
      select.dataset.previousValue = mapping;
      alert(`Field "${name.trim()}" created successfully.`);
    } catch (e) {
      console.error('create field', e);
      if (e.message !== 'Missing credentials') alert(e.message);
      select.value = prev;
    }
  }

  // Tabs
  function openTab(evt, tabName) {
    Array.from(document.getElementsByClassName('tabcontent')).forEach(el => el.style.display = 'none');
    Array.from(document.getElementsByClassName('tablinks')).forEach(el => el.classList.remove('active'));
    document.getElementById(tabName).style.display = 'block';
    evt.currentTarget.classList.add('active');
  }
  window.openTab = openTab;

  // Events
  document.getElementById('fetchFieldsBtn')?.addEventListener('click', fetchFields);
  document.getElementById('csvFileInput')?.addEventListener('change', e => { const f = e.target.files?.[0]; if (f) parseCSV(f); });
  document.getElementById('toggleFieldsBtn')?.addEventListener('click', toggleFieldsSection);
  document.getElementById('searchRecordsBtn')?.addEventListener('click', searchExistingRecords);
  document.getElementById('pushDataBtn')?.addEventListener('click', pushDataToPipedrive);
})();
</script>


</body>
</html>
